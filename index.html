<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc-markdown-css-theme" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="@sambacha" />
  <title>Transaction Inclusion Protocol</title>
  <link rel="stylesheet" href="css/theme.css" />
  <link rel="stylesheet" href="css/skylighting-solarized-theme.css" />
  <script defer="" src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" />
</head>
<body>

<header>
<h1 class="title">Transaction Inclusion Protocol</h1>
<blockquote class="metadata">
<p class="subtitle">InclusionBond Protocol Draft</p>
<p class="author">
      <a href="https://github.com/sambacha"><span class="citation" data-cites="sambacha">@sambacha</span></a>
  </p>
<p class="date before-toc"><time datetime="Tue Dec 20 23:47:20 UTC 20220">Tue Dec 20 23:47:20 UTC 20220</time></p>
</blockquote>
</header>

<nav id="TOC" role="doc-toc">
    <a href="..">‚Üê Return home</a><br>
    <strong>Contents</strong><label for="contents">‚äï</label>
  <input type="checkbox" id="contents">
  <ul>
  <li><a href="#abstract" id="toc-abstract">Abstract</a>
  <ul>
  <li><a href="#inclusionbond-design" id="toc-inclusionbond-design">InclusionBond Design</a></li>
  <li><a href="#phases-of-operation" id="toc-phases-of-operation">Phases of Operation</a>
  <ul>
  <li><a href="#settle" id="toc-settle">Settle</a></li>
  <li><a href="#exhaust" id="toc-exhaust">Exhaust</a></li>
  <li><a href="#specification" id="toc-specification">Specification</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#features" id="toc-features">Features</a></li>
  </ul>
</nav>

<main>
<div class="note blue">
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">‚ÑπÔ∏è Outline</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="https://github.com/jez/pandoc-markdown-css-theme/#license">‚Üí More information</a></td>
</tr>
</tbody>
</table>
</div>
<h1 id="abstract">Abstract</h1>
<div class="note yellow">
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">üëã Men at Work</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="#">‚Üí More information</a></td>
</tr>
</tbody>
</table>
</div>
<h2 id="inclusionbond-design">InclusionBond Design</h2>
<p>InclusionBond takes a different approach ‚Äì it incentives the correct execution rather than enforcing it. We set a hedging contract between a single block builder and the transaction issuer. This enables InclusionBond to have only a relatively-low overhead ‚Äì there is no need for elaborate proofs of misbehavior.<span class="sidenote-wrapper"><label for="sn-0" class="margin-toggle">&#8853;</label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="marginnote">The boundaries of this ‚Äôrational behavior implicitly assume no agreements are made outside this context, which is not, in a production sense, a safe bet.<br />
<br />
</span></span></p>
<p>Our implementation follows the smart contract wallet (SCW) design pattern. This design enables customizing the retrieval of the contract tokens, which, for InclusionBond, is done only through the Settle, Exhaust, and Recoup functions. Additionally, this design enables decoupling the transaction issuer (i.e., the party that pays the transaction fees) from the transaction signer (the party that creates the transaction). This, in turn, enables having one party, Seller, use her gas allocation (or pay the transaction fees) to confirm a transaction by the other party Buyer, using so-called meta transactions</p>
<p>Our implementation is compatible with EIP1559 since <code>txpayload</code> is a meta transaction, and the transaction by Seller that invokes the Settle is the one that pays the required base fee.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb1-1"><a href="#cb1-1"></a>Buyer</span>
<span id="cb1-2"><a href="#cb1-2"></a>Seller</span>
<span id="cb1-3"><a href="#cb1-3"></a>Underwriter</span></code></pre></div>
<h2 id="phases-of-operation">Phases of Operation</h2>
<p>InclusionBond operates in three phases.</p>
<p>At the setup phase, the gas-purchasing user (the Buyer) sets the contract parameters, namely:</p>
<ul>
<li>the target confirmation interval,</li>
<li>the required gas,</li>
<li>payment details.</li>
</ul>
<p>Buyer also locks the payment upfront, and then the gas-selling block builder (the Seller) can accept the contract by depositing a collateral of her own. At this point Buyer does not commit to a future transaction.</p>
<p>At the target execution phase, Buyer publishes a (zero fee) transaction of her choice, which Seller can then confirm through a designated Settle function. InclusionBond verifies the provided transaction was indeed created by Buyer, and if it executes successfully, it sends the funds to Seller.</p>
<p>But what happens if Buyer publish a transaction that exceeds the agreed-upon gas amount, or a transaction that fails, or maybe does not even publish a transaction at all? For that there exists an alternative function, exhaust, that enables Seller to extract the funds without any corporation from Buyer. However, to prevent Seller abusing this function, its invocation spends gas equal to the agreed-upon amount through repeated null operations. This construction results with the Settle function being preferred in case Buyer abides by the contract, while protecting Seller if not.</p>
<p>To analyze InclusionBond we first consider what are the possible interactions Buyer and Seller can have with it ‚Äì who can do what, and when. These, in turn, give rise to a game, which we analyze using the <code>subgame</code> perfect equilibrium solution concept. Our analysis confirms that fulfilling the contract as intended is the <code>subgame</code> perfect equilibrium for a wide range of practical parameters.</p>
<p>Consider two system participants, Buyer and Seller, with the following interests: Buyer requires <span class="math inline">g_{\text {alloc }}</span> gas allocated to a transaction of her choice in future blocks; Seller has a gas allocation of <span class="math inline">g_{\text {alloc }}</span> in such a suitable block, which she can sell for tokens.</p>
<p>We denote the transaction that Buyer wants to be included by <span class="math inline">t x_{\text {payload }}</span>, and the relevant block interval for its inclusion</p>
<p>by <span class="math inline">\left[b_{\text {start }}, b_{\text {end }}\right]</span>. Note that the content of <span class="math inline">t x_{\text {payload }}</span> is not necessarily known up to <span class="math inline">b_{\text {start }}</span>. We also denote the block interval in which Buyer wishes to assure the future allocation by <span class="math inline">\left[b_{\text {init }}, b_{a c c}\right]</span> such that init <span class="math inline">\leq</span> acc <span class="math inline">&lt;</span> start <span class="math inline">\leq</span> end.</p>
<p>The contract instance, the required gas for the future transaction, and a required collateral to be deposited by Seller. She also deposits the token payment for the future transaction confirmation. Following its initiation, the contract starts an acceptance block countdown, during which a Seller can accept it using a transaction. Additionally, accepting the contract requires Seller to deposit tokens as a collateral matching the collateral parameter. The collateral is returned conditioned on Seller further interacting with the contract. Either if Seller accepted the contract, or if the acceptance countdown is completed, the contract accepts no further interactions until the exec phase.</p>
<p>Towards or even during the exec phase, Buyer can publish txpayload. This allows Seller to Settle it, executing txpayload, and getting the payment and collateral tokens from the contract. This is the main functionality of InclusionBond ‚Äì enabling Seller to execute a transaction provided by Buyer. Alternatively, Seller can exhaust the contract, consuming the hedged gas on null operations, and then receiving its tokens. The motivation for this functionality is to enable Seller to claim the tokens, regardless if Buyer provides a transaction or not; this protects Seller from a faulty or malicious Buyer. However, the naive solution of letting Seller report Buyer as faulty is not sufficient: It allows a Seller to falsely accuse a correct Buyer, getting the contract tokens without providing the confirmation service. By making Seller waste equivalent gas, we remove her incentive to do so. If Seller has not accepted the contract, then Buyer can recoup the contract tokens using a transaction.</p>
<blockquote>
<p>Note: I hate the name Inclusion Bond, as these are no ‚Äòbonds‚Äô but fuck it.</p>
</blockquote>
<h3 id="settle">Settle</h3>
<p>Settle. The Settle function implements the main functionally of InclusionBond: Seller executing a transaction <span class="math inline">t x_{\text {provided }}</span> provided by Buyer, and receiving the agreed-upon payment for doing so.</p>
<p>This function takes as an input a transaction <span class="math inline">t x_{\text {provided }}</span>, and first verifies <span class="math inline">t x_{\text {provided }}</span> was issued by Buyer (line 20). Then, it verifies the invocation is within <span class="math inline">\left[b_{\text {start }}, b_{\text {end }}\right]</span> (line 21), that Seller had previously accepted (line 22), and that the invocation is by Seller (line 23). The contract then executes the operations of <span class="math inline">t x_{\text {provided }}</span> as a subroutine (line 24), marks its status completed (line 32), and sends payment <span class="math inline">+\varepsilon+</span> col tokens to Seller (line 33). Considering all operations except the execution of <span class="math inline">t x_{\text {provided }}</span>, the Settle function performs similar operations to those of Recoup. We therefore consider its gas consumption, aside from execution of <span class="math inline">t x_{\text {provided }}</span>, is also <span class="math inline">g_{\text {done }}</span>.</p>
<h3 id="exhaust">Exhaust</h3>
<p>The Exhaust function allows Seller to get payment+col tokens for expending <span class="math inline">g_{\text {alloc }}</span> gas during the required block interval. Its goal is to protect Seller from a spiteful Buyer, specifically from the case where Buyer does not publish a <span class="math inline">t x_{\text {provided }}</span> transaction, or publishes ones that consume more than <span class="math inline">g_{\text {alloc }}</span> gas. When Exhaust is invoked, the contract first verifies the invocation is within <span class="math inline">\left[b_{\text {start }}, b_{\text {end }}\right]</span> (line 28), that Seller had previously accepted (line 29), and that the invocation is by Seller (line 30). The contract then performs null operations consuming <span class="math inline">g_{\text {alloc }}</span> gas (line 31), marks its status completed (line 32), and sends Seller payment <span class="math inline">+</span> col tokens (line 33).</p>
<h3 id="specification">Specification</h3>
<p>Parameter : acc, start, end, block number operation ranges Parameter <span class="math inline">\quad: g_{\text {alloc }}</span>, required gas Parameter <span class="math inline">\quad: c o l</span>, the required collateral by Seller Parameter : payment, payment for execution Parameter <span class="math inline">\quad: \varepsilon</span>, additional payment for successful execution. Global Variable : current, current block number Variable <span class="math inline">\quad</span> : status <span class="math inline">\leftarrow \perp</span>, contract status variable Variable <span class="math inline">\quad: P K_{\text {Seller }} \leftarrow \perp</span>, public identifier of Seller Variable <span class="math inline">\quad: P K_{\text {Buyer }} \leftarrow \perp</span>, public identifier of Buyer</p>
<p>Function Exhaust (txIssuer, sentTokens): Assert: start <span class="math inline">\leq</span> current <span class="math inline">\leq</span> end Assert: status <span class="math inline">=</span> accepted Assert: <span class="math inline">P K_{\text {Seller }}=</span> txIssuer Perform null operations summing to <span class="math inline">g_{\text {alloc }}</span> gas status <span class="math inline">\leftarrow</span> completed Send payment <span class="math inline">+</span> col to <span class="math inline">P K_{\text {Seller }}</span></p>
<p>Function Settle (txIssuer, sentTokens; tx provided): Assert: <span class="math inline">t x_{\text {provided }}</span> was issued by <span class="math inline">PK _{\text {Buyer }}</span> Assert: start <span class="math inline">\leq</span> current <span class="math inline">\leq</span> end Assert: status <span class="math inline">=</span> accepted Assert: <span class="math inline">P K_{\text {Seller }}=</span> txIssuer Execute the operations of <span class="math inline">t x_{\text {provided }}</span> status <span class="math inline">\leftarrow</span> completed Send payment <span class="math inline">+\varepsilon+</span> col to <span class="math inline">P K_{\text {Seller }}</span></p>
<p>Function Accept (txIssuer, sentTokens): Assert: current <span class="math inline">\leq</span> acc Assert: status <span class="math inline">=</span> initiated Assert: sentTokens <span class="math inline">\geq</span> col <span class="math inline">P_{\text {Seller }} \leftarrow</span> txIssuer status <span class="math inline">\leftarrow</span> accepted</p>
<p>Function Initiate (txIssuer, sentTokens; acc, start, end, <span class="math inline">g_{\text {alloc }}</span>, col, <span class="math inline">\varepsilon</span> ): Assert: current <span class="math inline">\leq</span> acc <span class="math inline">&lt;</span> start <span class="math inline">\leq</span> end Assert: <span class="math inline">g_{\text {alloc }}&gt;0</span>, col <span class="math inline">\geq 0, \varepsilon \geq 0</span>, sentTokens <span class="math inline">\geq \varepsilon</span> Set acc, start, end, <span class="math inline">g_{\text {alloc }}</span>, col from inputs, payment <span class="math inline">\leftarrow</span> sentTokens <span class="math inline">-\varepsilon</span> <span class="math inline">P K_{\text {Buyer }} \leftarrow</span> txIssuer status <span class="math inline">\leftarrow</span> initiated</p>
<p>Game state <span class="math inline">N o L H</span> (in <span class="math inline">\varphi_{\text {exec }}</span> ) takes place after Nature draws <span class="math inline">\pi_{\text {exec }} \sim F</span>. In this state, Buyer can pay the gas-price <span class="math inline">\pi_{\text {exec }}</span> o have <span class="math inline">t x_{\text {payload }}</span> confirmed (action <span class="math inline">a_{p u b T x}</span> ), incurring the fee cost <span class="math inline">g_{\text {alloc }} \cdot \pi_{\text {exec }}</span>, but have <span class="math inline">t x_{\text {payload }}</span> confirmed. Alternatively, she</p>
<p><span class="math inline">W_{\text {Seller }}\left(\pi_{\text {exec }}\right.</span>, PublishTx, <span class="math inline">\left.\bar{s}_{\text {spe }}\right)=</span> <span class="math inline">\begin{cases}W_{\text {Seller }}\left(\pi_{\text {exec }}, \text { FulfillTx, } \bar{s}_{\text {spe }}\right), &amp; \pi_{\text {exec }}&lt;\frac{\text { payment }+\text { col }+\varepsilon}{g_{\text {alloc }}+g_{\text {done }}} \\ W_{\text {Seller }}\left(\pi_{\text {exec }}, \text { FulfillNoTx, } \bar{s}_{\text {spe }}\right), &amp; \pi_{\text {exec }}&gt;\frac{\text { payment }+\text { col }+\varepsilon}{g_{\text {alloc }}+g_{\text {done }}}\end{cases}</span> and <span class="math inline">W_{\text {Buyer }}\left(\pi_{\text {exec }}\right.</span>, PublishTx, <span class="math inline">\left.\bar{s}_{\text {spe }}\right)=</span> <span class="math inline">\left\{\begin{array}{ll}W_{\text {Buyer }}\left(\pi_{\text {exec }}, \text { FulfillTx, } \bar{s}_{\text {spe }}\right), &amp; \pi_{\text {exec }}&lt;\frac{\text { payment }+\text { col }+\varepsilon}{g_{\text {alloc }}+g_{\text {done }}} \\ W_{\text {Buyer }}\left(\pi_{\text {exec }}, \text { FulfillNoTx, } \bar{s}_{\text {spe }}\right), &amp; \pi_{\text {exec }}&gt;\frac{\text { payment }+\text { col }+\varepsilon}{g_{\text {alloc }}+g_{\text {done }}}\end{array}\right.</span>.</p>
<p>The maximum allowed gap between the epoch of a routing peer and the incoming message. Should be set based on measures the maximum number of epochs that can elapse since a message gets routed from its origin to all the other peers in the network. Can be calculated as:</p>
<p>ms delay + clock / epoch len.</p>
<hr />
<div class="note blue">
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">‚ÑπÔ∏è Erratta</td>
</tr>
<tr class="even">
<td style="text-align: left;"><a href="#">‚Üí More information</a></td>
</tr>
</tbody>
</table>
</div>
<h1 id="features">Features</h1>
<p class="signoff">
<a href="/">‚Üë Back to the top</a>
</p>
</main>

<footer>
<p class="signoff">
  <a href="..">‚Üê Return home</a>
</p>
</footer>
<script>
;(function() {
  // Non-essential if user has JavaScript off. Just makes checkboxes look nicer.
  var selector = '.task-list > li > input[type="checkbox"]';
  var checkboxes = document.querySelectorAll(selector);
  Array.from(checkboxes).forEach((checkbox) => {
    var wasChecked = checkbox.checked;
    checkbox.disabled = false;
    checkbox.addEventListener('click', (ev) => {ev.target.checked = wasChecked});
  });
})();
</script>
<link href="/_pagefind/pagefind-ui.css" rel="stylesheet">
<script src="/_pagefind/pagefind-ui.js" type="text/javascript"></script>

<div id="search"></div>
<script>
    window.addEventListener('DOMContentLoaded', (event) => {
        new PagefindUI({ element: "#search" });
    });
</script>
</body>
</html>
